本番では途中参加で317位。中途半端な参加になってしまい、やり切った感がなく悔しい思いをしたので、AHC018を復習する。

1. サンプルコードと同じことをやる
  それぞれの家から1つ目の水源に接続する -> 一つ目のサンプルケースのコストは607614。

2. Prim法を用いて、全ての家がマンハッタン距離に関してコスト最小になるような最小全域木を求めてみる
  ほとんどのテストケースでスコアの改善が見られる。
  AtCoder上で提出すると、得点は14257633。

  seedが0から99のテストケースを回した結果、スコアの合計は32219895で、統計量は下のようになった。
  count	100.000000
  mean	322198.950000
  std	194482.406775
  min	41600.000000
  25%	149236.500000
  50%	256818.000000
  75%	470912.000000
  max	817608.000000

3. 試掘をしてみる。
  調査したところ、テストケース100件の硬さの10,20,...,90パーセント点は下のようになっていた。
  array([  12.,   24.,   56.,  121.,  236.,  434.,  788., 1454., 2608.])
  20マスごとに格子点を作成して、パワー50で5回まで掘削して頑丈さを見積もることにする。
  掘削しきれない場合、この段階では適当に頑丈さを500ということにしておく。

  まだこの段階では2.と家から水源までの接続のやり方は変えていないので、ただコストだけがかかることになる。
  コストの増分を確認する。

  count	100.000000
  mean	356802.600000
  std	203108.362446
  min	64824.000000
  25%	176230.000000
  50%	304958.000000
  75%	498263.500000
  max	901624.000000

  平均で30000ポイントほど悪化している。

4. 試掘の結果を使って、ショートカットをする
  マンハッタン距離が最小の道を突き進む場合、非常に硬い岩盤も無理矢理通過するルートになり効率が悪くなることがある。
  試掘した格子点の間をメッシュ状に繋いで、辺の重みを端点のコストの重みとして、より効率的な道が探索できないか。
  最初はPrim法で最小全域木を求めたが、通過する必要のない頂点が大量に含まれていてこれでは無駄が多すぎる。

  今まで、水路や家の間の距離はマンハッタン距離としていたが、試掘によって求めた推定コストを使いたいというのがモチベーション。
  格子点間の辺のコストは、端点のコストの平均とする。
  もちろん、家や水源は格子点上に載っていないので、最も近い格子点を代表点とする。
  その際、ワーシャルフロイド法を用いて格子点同士の距離を求めておく。

  格子点上を辿って頂点を接続していく際に、ワーシャルフロイド法の経路復元がしたい。
  [ワーシャル-フロイド法の経路復元](https://zeosutt.hatenablog.com/entry/2015/05/05/045943)を参考にして、
  i から j への最短経路における i の一つ後の点を管理する `next[i][j]` を導入する。

  こうすると、手元のテストケースでは22115600と、かなり改善している。
  提出すると、9568325点。

  count	100.000000
  mean	221156.000000
  std	151196.999375
  min	55942.000000
  25%	122257.000000
  50%	176089.500000
  75%	276856.000000
  max	809828.000000

5. 格子点上の代表点の取り方を調整する
  今まで、家や水源からもっとも近い格子点を代表点としていたが、
  周辺の格子点を代表点とした場合のコストをそれぞれ求めて、コストが最小となる点を代表点とする。

  count	100.000000
  mean	206446.330000
  std	141390.825681
  min	53871.000000
  25%	107811.000000
  50%	164734.000000
  75%	268930.500000
  max	950940.000000

  最大コストは増えてしまっているが全体としては改善した。
  提出すると、8863658点。本番よりも改善した。