本番では途中参加で317位。中途半端な参加になってしまい、やり切った感がなく悔しい思いをしたので、AHC018を復習する。

1. サンプルコードと同じことをやる
  それぞれの家から1つ目の水源に接続する -> 一つ目のサンプルケースのコストは607614。

2. Prim法を用いて、全ての家がマンハッタン距離に関してコスト最小になるような最小全域木を求めてみる
  ほとんどのテストケースでスコアの改善が見られる。
  AtCoder上で提出すると、得点は14257633。

  seedが0から99のテストケースを回した結果、スコアの合計は32219895で、統計量は下のようになった。
  count	100.000000
  mean	322198.950000
  std	194482.406775
  min	41600.000000
  25%	149236.500000
  50%	256818.000000
  75%	470912.000000
  max	817608.000000

3. 試掘をしてみる。
  調査したところ、テストケース100件の硬さの10,20,...,90パーセント点は下のようになっていた。
  array([  12.,   24.,   56.,  121.,  236.,  434.,  788., 1454., 2608.])
  20マスごとに格子点を作成して、パワー50で5回まで掘削し、コストの変化を見る。
  まだこの段階では2.と家から水源までの接続のやり方は変えていないので、ただコストだけがかかることになる。

  count	100.000000
  mean	356802.600000
  std	203108.362446
  min	64824.000000
  25%	176230.000000
  50%	304958.000000
  75%	498263.500000
  max	901624.000000

  平均で30000ポイントほど悪化している。

4. 試掘の結果を使って、ショートカットをする
  マンハッタン距離が最小の道を突き進む場合、非常に硬い岩盤も無理矢理通過するルートになり効率が悪くなることがある。
  試掘した格子点の間をメッシュ状に繋いで、辺の重みを端点のコストの重みとして、より効率的な道が探索できないか。
  最初はPrim法で最小全域木を求めたが、通過する必要のない頂点が大量に含まれていてこれでは無駄が多すぎる。

  今まで、水路や家の間の距離はマンハッタン距離としていたが、試掘によって求めた推定コストを使いたいというのがモチベーション。もちろん、家や水源は格子点上に載っていないので、最も近い格子点を代表点とする。
  その際、ワーシャルフロイド法を用いて格子点同士の距離を求めておく。

  格子点上を辿って頂点を接続していく際に、ワーシャルフロイド法の経路復元がしたい。
  [ワーシャル-フロイド法の経路復元](https://zeosutt.hatenablog.com/entry/2015/05/05/045943)を参考にして、
  i から j への最短経路における i の一つ後の点を管理する `next[i][j]` を導入する。
  
